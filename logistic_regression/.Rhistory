library(tidyverse)
library(dplyr)
library(tidyr)
library(readr)
library(tibble)
library(stats)
library(ggplot2)
library(mltools)
library(data.table)
library(caret)
library(aod)
library(ROCR)
library(InformationValue)
# Set the seed
set.seed(1002476)
# Load the data
raw_data <- read.csv("input/combined_wine_binary_quality.csv", header = TRUE)
names(raw_data) <- c("wine_type", "fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar", "chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density", "pH", "sulphates", "alcohol", "quality")
factor_wines <- factor(raw_data$quality, labels = c("less than 5",
"greater than or equal to 5"))
factor_wines
wines$quality <- factor(wines$quality)
is.factor(factor_wines)
sample_size <- floor(0.80 * nrow(raw_data))
train_index <- sample(seq_len(nrow(raw_data)), size = sample_size)
train <- raw_data[train_index, ]
test <- raw_data[-train_index, ]
predicted <- plogis(predict(model, test))
# Determine the optimal cut-off point
optCutOff <- optimalCutoff(test$quality, predicted)[1]
predicted <- plogis(predict(model, test))
model <- glm(quality ~ wine_type + fixed_acidity + volatile_acidity
+ citric_acid + residual_sugar + chlorides + free_sulfur_dioxide
+ total_sulfur_dioxide + density + pH + sulphates
+ alcohol, data = train, family = binomial(link="logit"))
predicted <- plogis(predict(model, test))
# Determine the optimal cut-off point
optCutOff <- optimalCutoff(test$quality, predicted)[1]
optCutOff
summary(model)
vif(model)
misClassError(test$quality, predicted, threshold = optCutOff)
wald.test(b = coef(model), Sigma = vcov(model), Terms = 2:13)
fitted.results <- predict(model, newdata = subset(test), type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
misClasificError <- mean(fitted.results != test$quality)
print(paste('Accuracy', 1-misClasificError))
plotROC(test$quality, predicted)
Concordance(test$quality, predicted)
sensitivity(test$quality, predicted, threshold = optCutOff)
# [1] 0.9984051
specificity(test$quality, predicted, threshold = optCutOff)
# [1] 0.1086957
confusionMatrix(test$quality, predicted, threshold = optCutOff)
# Load the libraries
library(tidyverse)
library(dplyr)
library(tidyr)
library(readr)
library(tibble)
library(stats)
library(ggplot2)
library(mltools)
library(data.table)
library(caret)
library(aod)
library(ROCR)
library(InformationValue)
# Set the seed
set.seed(1002476)
# Load the data
raw_data <- read.csv("input/combined_wine_binary_quality.csv", header = TRUE)
# Rename the columns
names(raw_data) <- c("wine_type", "fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar", "chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density", "pH", "sulphates", "alcohol", "quality")
# View header
head(raw_data, n=10)
# Since logistic regression requires a binomial, translate the quality
# column into two factors: quality scores below (0) and above (1) a value of
# the median quality score (5).
factor_wines <- factor(raw_data$quality, labels = c("less than 5",
"greater than or equal to 5"))
factor_wines
wines$quality <- factor(wines$quality)
# Check if the variables are factors
is.factor(factor_wines)
contrasts(factor_wines)
# Split the data into train and test sets using the caret package
# Partition the data into train and test sets (80/20)
sample_size <- floor(0.80 * nrow(raw_data))
train_index <- sample(seq_len(nrow(raw_data)), size = sample_size)
train <- raw_data[train_index, ]
test <- raw_data[-train_index, ]
# Build the logistic regression model
model <- glm(quality ~ wine_type + fixed_acidity + volatile_acidity
+ citric_acid + residual_sugar + chlorides + free_sulfur_dioxide
+ total_sulfur_dioxide + density + pH + sulphates
+ alcohol, data = train, family = binomial(link="logit"))
# Predicted scores
predicted <- plogis(predict(model, test))
# Determine the optimal cut-off point
optCutOff <- optimalCutoff(test$quality, predicted)[1]
# optCutOff = 0.6799987
# Summarize the findings
summary(model)
# Check for multicollinearity in the model
vif(model)
misClassError(test$quality, predicted, threshold = optCutOff)
#  0.0377
# Run an ANOVA
anova(model, test="Chisq")
## CIs using profiled log-likelihood
confint(model)
## CIs using standard errors
confint.default(model)
# Test for an overall effect of rank using the wald.test function of the aod
# library. The order in which the coefficients are given in the
# table of coefficients is the same as the order of the terms in the model.
wald.test(b = coef(model), Sigma = vcov(model), Terms = 2:13)
# Chi-squared test:
# X2 = 249.5, df = 12, P(> X2) = 0.0
# Above, we briefly evaluated the fitting of the model,
# now test model by predicting y on a new set of data.
fitted.results <- predict(model, newdata = subset(test), type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
misClasificError <- mean(fitted.results != test$quality)
print(paste('Accuracy', 1-misClasificError))
# Accuracy = 0.960769230769231 = 96.54%
# Plot the ROC and AUC
plotROC(test$quality, predicted)
# Of all combinations of 1-0 pairs (actuals), concordance is the percentage
# of pairs, whose scores of positives are greater than the scores of negatives.
# For a perfect model, this will be 100%.
# The higher the concordance, the better is the quality of model.
Concordance(test$quality, predicted)
# Concordance = [1] 0.7348832 = ~73%
# Not that great of a fit
sensitivity(test$quality, predicted, threshold = optCutOff)
# [1] 0.9984051
specificity(test$quality, predicted, threshold = optCutOff)
# [1] 0.1086957
confusionMatrix(test$quality, predicted, threshold = optCutOff)
# The columns are actuals, while rows are predicted values
#    0    1
# 0  5    2
# 1 41 1252
install.packages("pROC")
predictions <- log_reg(test, size=10)
fitted.results <- predict(model, newdata = subset(test), type='response')
fitted.results <- ifelse(fitted.results > 0.5,1,0)
fitted.results
roc <- calculate_roc(predicted, 1, 2, n = 100)
# https://github.com/joyofdata/joyofdata-articles/blob/master/roc-auc/calculate_roc.R
roc <- calculate_roc(predictions, 1, 2, n = 100)
# https://github.com/joyofdata/joyofdata-articles/blob/master/roc-auc/plot_roc.R
plot_roc(roc, 0.7, 1, 2)
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
coord_fixed() +
geom_line(aes(threshold,threshold), color=rgb(0,0,1,alpha=0.5)) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_cost, ncol=2, sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
roc <- calculate_roc(predictions, 1, 2, n = 100)
calculate_roc <- function(df, cost_of_fp, cost_of_fn, n=100) {
tpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 1) / sum(df$survived == 1)
}
fpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 0) / sum(df$survived == 0)
}
cost <- function(df, threshold, cost_of_fp, cost_of_fn) {
sum(df$pred >= threshold & df$survived == 0) * cost_of_fp +
sum(df$pred < threshold & df$survived == 1) * cost_of_fn
}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tpr <- sapply(roc$threshold, function(th) tpr(df, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(df, th))
roc$cost <- sapply(roc$threshold, function(th) cost(df, th, cost_of_fp, cost_of_fn))
return(roc)
}
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
coord_fixed() +
geom_line(aes(threshold,threshold), color=rgb(0,0,1,alpha=0.5)) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_cost, ncol=2, sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
roc <- calculate_roc(predictions, 1, 2, n = 100)
roc <- calculate_roc(predicted, 1, 2, n = 100)
roc <- calculate_roc(predicted, 1, 2, n = 100)
library(gridExtra)
library(ggplot2)
library(party)
library(pROC)
df_tree <- dec_tree()
plot_pred_type_distribution(df_tree, 0.7)
roc_tree <- calculate_roc(df_tree, 1, 3)
df_reg <- log_reg()
roc_reg <- calculate_roc(df_reg, 1, 3)
plot_roc(roc_reg)
pROC::auc(df$survived, df$pred)
# plot(roc$threshold, roc$cost)
calculate_roc <- function(df, cost_of_fp, cost_of_fn, n=100) {
tpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 1) / sum(df$survived == 1)
}
fpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 0) / sum(df$survived == 0)
}
cost <- function(df, threshold, cost_of_fp, cost_of_fn) {
sum(df$pred >= threshold & df$survived == 0) * cost_of_fp +
sum(df$pred < threshold & df$survived == 1) * cost_of_fn
}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tpr <- sapply(roc$threshold, function(th) tpr(df, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(df, th))
roc$cost <- sapply(roc$threshold, function(th) cost(df, th, cost_of_fp, cost_of_fn))
return(roc)
}
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
coord_fixed() +
geom_line(aes(threshold,threshold), color=rgb(0,0,1,alpha=0.5)) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_cost, ncol=2, sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
plot_pred_type_distribution <- function(df, threshold) {
v <- rep(NA, nrow(df))
v <- ifelse(df$pred >= threshold & df$survived == 1, "TP", v)
v <- ifelse(df$pred >= threshold & df$survived == 0, "FP", v)
v <- ifelse(df$pred < threshold & df$survived == 1, "FN", v)
v <- ifelse(df$pred < threshold & df$survived == 0, "TN", v)
df$pred_type <- v
ggplot(data=df, aes(x=survived, y=pred)) +
geom_violin(fill=rgb(1,1,1,alpha=0.6), color=NA) +
geom_jitter(aes(color=pred_type), alpha=0.6) +
geom_hline(yintercept=threshold, color="red", alpha=0.6) +
scale_color_discrete(name = "type") +
labs(title=sprintf("Threshold at %.2f", threshold))
}
roc <- calculate_roc(predictions, 1, 2, n = 100)
plotROC(test$quality, predicted)
roc <- calculate_roc(predicted, 1, 2, n = 100)
roc <- calculate_roc(test, 1, 2, n = 100)
roc
plot_roc(roc, 0.7, 1, 2)
install.packages("party")
library(party)
library(ggplot2)
library(party)
library(pROC)
df_tree <- dec_tree()
plot_pred_type_distribution(df_tree, 0.7)
roc_tree <- calculate_roc(df_tree, 1, 3)
df_reg <- log_reg()
roc_reg <- calculate_roc(df_reg, 1, 3)
plot_roc(roc_reg)
pROC::auc(df$survived, df$pred)
# plot(roc$threshold, roc$cost)
calculate_roc <- function(df, cost_of_fp, cost_of_fn, n=100) {
tpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 1) / sum(df$survived == 1)
}
fpr <- function(df, threshold) {
sum(df$pred >= threshold & df$survived == 0) / sum(df$survived == 0)
}
cost <- function(df, threshold, cost_of_fp, cost_of_fn) {
sum(df$pred >= threshold & df$survived == 0) * cost_of_fp +
sum(df$pred < threshold & df$survived == 1) * cost_of_fn
}
roc <- data.frame(threshold = seq(0,1,length.out=n), tpr=NA, fpr=NA)
roc$tpr <- sapply(roc$threshold, function(th) tpr(df, th))
roc$fpr <- sapply(roc$threshold, function(th) fpr(df, th))
roc$cost <- sapply(roc$threshold, function(th) cost(df, th, cost_of_fp, cost_of_fn))
return(roc)
}
plot_roc <- function(roc, threshold, cost_of_fp, cost_of_fn) {
library(gridExtra)
norm_vec <- function(v) (v - min(v))/diff(range(v))
idx_threshold = which.min(abs(roc$threshold-threshold))
col_ramp <- colorRampPalette(c("green","orange","red","black"))(100)
col_by_cost <- col_ramp[ceiling(norm_vec(roc$cost)*99)+1]
p_roc <- ggplot(roc, aes(fpr,tpr)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
coord_fixed() +
geom_line(aes(threshold,threshold), color=rgb(0,0,1,alpha=0.5)) +
labs(title = sprintf("ROC")) + xlab("FPR") + ylab("TPR") +
geom_hline(yintercept=roc[idx_threshold,"tpr"], alpha=0.5, linetype="dashed") +
geom_vline(xintercept=roc[idx_threshold,"fpr"], alpha=0.5, linetype="dashed")
p_cost <- ggplot(roc, aes(threshold, cost)) +
geom_line(color=rgb(0,0,1,alpha=0.3)) +
geom_point(color=col_by_cost, size=4, alpha=0.5) +
labs(title = sprintf("cost function")) +
geom_vline(xintercept=threshold, alpha=0.5, linetype="dashed")
sub_title <- sprintf("threshold at %.2f - cost of FP = %d, cost of FN = %d", threshold, cost_of_fp, cost_of_fn)
grid.arrange(p_roc, p_cost, ncol=2, sub=textGrob(sub_title, gp=gpar(cex=1), just="bottom"))
}
plot_pred_type_distribution <- function(df, threshold) {
v <- rep(NA, nrow(df))
v <- ifelse(df$pred >= threshold & df$survived == 1, "TP", v)
v <- ifelse(df$pred >= threshold & df$survived == 0, "FP", v)
v <- ifelse(df$pred < threshold & df$survived == 1, "FN", v)
v <- ifelse(df$pred < threshold & df$survived == 0, "TN", v)
df$pred_type <- v
ggplot(data=df, aes(x=survived, y=pred)) +
geom_violin(fill=rgb(1,1,1,alpha=0.6), color=NA) +
geom_jitter(aes(color=pred_type), alpha=0.6) +
geom_hline(yintercept=threshold, color="red", alpha=0.6) +
scale_color_discrete(name = "type") +
labs(title=sprintf("Threshold at %.2f", threshold))
}
roc <- calculate_roc(test, 1, 2, n = 100)
plot_roc(roc, 0.7, 1, 2)
plot_roc(roc, 0.8, 1, 2)
auc(predictions$quality, predictions$pred)
auc(test$quality)
plotROC(test$quality, predicted)
plotAUC(test$quality, predicted)
ROC1 <- roc(test$quality, test$Prediction1)
ROC1 <- roc(test$quality, test$predicted)
ROC1 <- roc(test$quality)
ROC1 <- roc(test$quality, predicted)
plot(ROC1, col = "blue")
AUC1 <- auc(ROC1)
AUC1
ROC1
